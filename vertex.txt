#version 300 es

#define PF
// PV - Per-vertex
// PF - Per-fragment
#define VS
// VS - view-space
// OS - object-space

// OBJECT SPACE
layout (location = 0) in vec4 aPosition;
layout (location = 1) in vec3 aNormal;

// TEXTURE SPACE
layout (location = 2) in vec4 aTexcoord;

// TRANSFORM UNIFORMS
uniform mat4 uModelMat;
uniform mat4 uViewMat;
uniform mat4 uProjMat;
uniform mat4 uViewProjMat;

// VARYINGS

// PER-FRAGMENT: individual components
out vec4 vNormal;
// out vec2 vTexcoord
out vec4 vTexcoord;

// PER-VERTEX VARYINGS
#ifdef PV
out vec4 vColor;
#endif

// PER-FRAGMENT VARYINGS
#ifdef PF
out vec4 vPosClip;
out vec4 vPosSurface;
out vec3 vNLight[3];
out float vLightDist[3];
out vec4 vLightColor[3];
out float vLightInt[3];
out vec4 vLightCenter[3];
#endif

// Structure for containing a pointlight
struct PointLight
{
	vec4 center; 		// Location of the light source
	vec4 color;			// Color of the light
	float intensity;		// Intensity of the light
};

// initLight: Initializes a pointlight 
//		vec4 center: 		the position of the light in world space
//		vec4 color: 		the color of the light
//		float intensity:	the intensity of the light
void initLight(in vec4 center, in vec4 color, in float intensity, 
				out PointLight light)
{
	light.center = center;
	light.color = color;
	light.intensity = intensity;
}

// Structure for containing lighting info. Calculated prior to the vertex / fragment split
//		vec3 distVec:		the distance vector between the light and the surface
//		float distVecSq:	the distance squared between the light and the surface
//		float lightDist:	the distance float between the light and the surface
//		vec3 nLight:		the normalized light vector
//		vec3 nNorm:			the normalized surface normal
struct LightingInfo
{
	vec3 distVec;
	float distVecSq;
	float lightDist;
	vec3 nLight;
};

void initLightingInfo(in vec4 posClip, in vec4 posSurface, in PointLight light, out LightingInfo li)
{
	li.distVec = vec3(light.center - posSurface);
	li.distVecSq = dot(li.distVec, li.distVec);
	li.lightDist = sqrt(li.distVecSq);
	li.nLight = li.distVec / li.lightDist;
}

// attenuation: calculate attenuation for the light
//		float lightDist:		the distance to the light from the surface
//		float lightIntensity:	the intensity of the light
float attenuation(in float lightDist, in float lightIntensity)
{
	// Calulate the distance / intensity for faster calculations
	float distIntensity = lightDist / lightIntensity; 
	return 1. /(1. + distIntensity + (distIntensity * distIntensity) );
}

// lambertian: calculate lambertian reflectance with attenuation
//		vec3 nNorm:			the normalized normal of the surface
//		vec3 nLight:		the normalized vector of the light
//		PointLight light:	the light to get the intensity from
//		float lightDist:	the distance to the light from the surface
float lambertian(in vec3 nNorm, in vec3 nLight, in PointLight light, in float lightDist)
{
	// Calculate the diffuse coefficient
	float kD = max(0., dot(nNorm, nLight));
	// Calculate the attenuation
	float atten = attenuation(lightDist, light.intensity);
	// return the diffuse intensity (diffuse coefficient * attenuation)
	return kD * atten;
}

// phong: calculate phong reflectance
//		vec4 posClip:		the object in clip space (used for the viewer vector)
//		vec4 posSurface:	the position of the surface (view or object)
//		vec3 nLight:		the normalized vector of the light
//		vec3 nNorm:			the normalized normal of the surface
float phong(in vec4 posClip, in vec4 posSurface, in vec3 nLight, in vec3 nNorm)
{
	// Get the normal view vector by subtracting the posSurface from the posClip
	vec3 nViewVec = normalize(vec3(posClip - posSurface));
	// Calculate the reflected light vector by taking the inverse of the light (pointing towards sphere))
	vec3 nRefLightVec = reflect(-nLight, nNorm);
	// Specular coefficient
	float kS = max(0., dot(nRefLightVec, nViewVec));
	// Get the specular intensity by squaring the specular coefficient a lot
	float iS = kS * kS;
	iS *= iS;
	iS *= iS; 
	iS *= iS;  
	iS *= iS;
	iS *= iS;
	return iS;
}

// lighting: calculates the color after lighting the sceen
//		vec4 posClip:		the object in clip space
//		vec4 posSurface:	the position of the surface (view or object)
//		PointLight light:	the light that is being calculated about
vec4 lighting(in vec4 posClip, in vec4 posSurface, in vec3 nNorm,
			 in PointLight light, in LightingInfo li)
{
	
	float iD = lambertian(nNorm, li.nLight, light, li.lightDist);
	float iS = phong(posClip, posSurface, li.nLight, nNorm);
	return (iD * vec4(1.0) + iS * vec4(1.)) * light.color;
}

void main()
{
	// PERSPECTIVE PIPELINE
	mat4 modelViewMat = uViewMat * uModelMat;	
	vec4 posCamera = modelViewMat * aPosition;	
	vec4 posSurface;
	
	vec4 posClip = uProjMat * posCamera;
	gl_Position = posClip;
	
	// NORMAL PIPELINE
	mat3 normalMatrix = transpose(inverse(mat3(modelViewMat)));
	
	// TEXCOORD PIPELINE
	mat4 atlasMat = mat4(0.5, 0.0, 0.0, 0.0,
						 0.0, 0.5, 0.0, 0.0,
						 0.0, 0.0, 1.0, 0.0,
						 0.25, 0.25, 0.0, 1.0);
	vec4 uv_atlas = atlasMat * aTexcoord;
	vTexcoord = aTexcoord;
	
	// LIGHTING PIPELINE
	// The matrix modifier for the lights will depend
	// on whether it is in view-space or object space
	//
	// All the lights centers' will be adjusted by the lMatModifier
	mat4 lMatModifier;
	
	#ifdef VS // View space
	lMatModifier = uViewMat;
	posSurface = posCamera;
	#endif
	
	#ifdef OS // Object space
	lMatModifier = inverse(uModelMat);
	posSurface = aPosition;
	#endif
	
	
	// LIGHT SETUP
	PointLight lights[3];
	initLight(vec4(1.0, 5.0, 3.0, 1.0), vec4(1.0), 100., lights[0]);
	lights[0].center = lMatModifier * lights[0].center;
	
	initLight(vec4(-8.0, 1.0, -5.0, 1.0), vec4(1.0), 100., lights[1]);
	lights[1].center = lMatModifier * lights[1].center;

	initLight(vec4(-3.0, -20.0, 8.0, 1.0), vec4(1.0), 100., lights[2]);
	lights[2].center = lMatModifier * lights[2].center;
	
	// LIGHTING INFO SETUP
	LightingInfo info[3];
	initLightingInfo(posClip, posSurface, lights[0], info[0]);
	initLightingInfo(posClip, posSurface, lights[1], info[1]);
	initLightingInfo(posClip, posSurface, lights[2], info[2]);
	
	vNormal = vec4(normalMatrix * aNormal, 0.0);
	
	#ifdef PV // PER-VERTEX
	// Go through all the lights and color the sphere
	for(int i = 2; i >= 0; --i)
	{
		vColor += lighting(posClip, posSurface, vec3(vNormal), lights[i], info[i]);
	}
	#endif

	#ifdef PF // PER-FRAGMENT
	// Send the appropriate data over to 
	
	vPosClip = posClip;
	vPosSurface = posSurface;
	
	vNLight[0] = info[0].nLight;
	vNLight[1] = info[1].nLight;
	vNLight[2] = info[2].nLight;
	
	vLightDist[0] = info[0].lightDist;
	vLightDist[1] = info[1].lightDist;
	vLightDist[2] = info[2].lightDist;
	
	vLightColor[0] = lights[0].color;
	vLightColor[1] = lights[1].color;
	vLightColor[2] = lights[2].color;
	
	vLightInt[0] = lights[0].intensity;
	vLightInt[1] = lights[1].intensity;
	vLightInt[2] = lights[2].intensity;
	
	vLightCenter[0] - lights[0].center;
	vLightCenter[1] - lights[1].center;
	vLightCenter[2] - lights[2].center;
	#endif
	
	//vTexcoord = aTexcoord;
}