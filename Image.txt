//   Copyright 2020 Colin Deane
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//	   		http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//		File name: Image
//		Purpose: Perform a variety of compositing functions on the output of the other buffers
//
// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> IMAGE TAB (final)

//------------------------------------------------------------
// SHADERTOY MAIN

// COMPOSITING FUNCTIONS

// addition: adds the blur to the original
//	original:	input original color (Buffer A)
//	blur:		input blur color (Buffer C)	
color4 addition(in color4 original, in color4 blur)
{
 	return original + blur;   
}

// cMix: mixes the blur with the original
//	original:	input original color (Buffer A)
//	blur:		input blur color (Buffer C)
color4 cMix(in color4 original, in color4 blur)
{
 	return mix(original, blur, .1);   
}

// screen: Double inversion and multiplication
//	original:	input original color (Buffer A)
//	blur:		input blur color (Buffer C)
// Source for screen function comes from Wikipedia
//		Link: https://en.wikipedia.org/wiki/Blend_modes#Screen
color4 screen(in color4 original, in color4 blur, in float weight)
{
 	return 1.0 - weight * (1.0 - original) * (1.0 - blur);   
}

// overlay: overlay the original with the blur
//	original:	input original color (Buffer A)
//	blur:		input blur color (Buffer C)
// Source for overlay function comes from Wikipedia
//		Link: https://en.wikipedia.org/wiki/Blend_modes#Overlay
color4 overlay(in color4 original, in color4 blur, in color4 originalblurx2)
{
    float luma =  calcLuma(original);
    if(luma < 0.5)
    {
    	return originalblurx2;    
    }
    
 	return screen(original, blur, 2.0);   
	// OLD: return 1.0 - 2.0 * (1.0 - original) * (1.0 - blur);
}

color4 softLight(in color4 original, in color4 blur, in color4 originalblurx2)
{
 	return (1. - 2. * blur) * original * original + originalblurx2;   
}

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // setup
    // UV for input image
    sCoord uv = fragCoord / iChannelResolution[0].xy;
        
    color4 blur = texture(iChannel0, uv);
    color4 original = texture(iChannel1, uv);
    
    // COMPOSITE COLORS
    
    color4 originalblurx2 = 2. * original * blur;
    
    fragColor = addition(original, blur);
    //fragColor = cMix(original, blur);
    //fragColor = overlay(original, blur, originalblurx2);
    //fragColor = screen(original, blur, 1.0);
    //fragColor = softLight(original, blur, originalblurx2);
    
}