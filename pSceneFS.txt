#version 300 es

//   Copyright 2020 Colin Deane
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//	   		http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//	 File name: pSceneFS
//	 Purpose: Output the scene pass as a solid color or a texture.
//		Also allows the user to also choose if they want lighting or not
//
//	Sources used:
//		Joao Paulo's Crystal Texture and Normal Map. Licensed under CC0
//			Link: https://3dtextures.me/2020/07/01/crystal-004/

// Choose between TEXTURE and SOLIDCOLOR
#define TEXTURE
// Comment out LIGHTING for no lighting
#define LIGHTING

#ifdef GL_ES
precision highp float;
#endif // GL_ES

// Get varyings from the VS
in vec4 vNormal;
in vec4 vPosClip;
in vec4 vPosSurface;
in vec3 vLightPos[2]; 			// Light position
in vec4 vLightColor[2];			// Light color
in float vLightIntensity[2];	// Light intensity
in vec3 vLightDir[2];			// Light direction (a.k.a. normLight)

layout (location = 0) out vec4 rtFragColor;

uniform sampler2D uTex;
uniform sampler2D uTexNormalMap;

// Structure for containing lighting info.
//		vec3 distVec:		the distance vector between the light and the surface
//		float distVecSq:	the distance squared between the light and the surface
//		float lightDist:	the distance float between the light and the surface
struct LightingInfo
{
	vec3 distVec;
	float distVecSq;
	float lightDist;
};

// initLightingInfo: Helper function to initialized lighting info
//		vec4 posSurface:		the position of the surface
//		vec3 lightCenter:		the light center 
void initLightingInfo(in vec4 posSurface, in vec3 lightCenter, out LightingInfo li)
{
	li.distVec = lightCenter - vec3(posSurface);
	li.distVecSq = dot(li.distVec, li.distVec);
	li.lightDist = sqrt(li.distVecSq);
}

// attenuation: calculate attenuation for the light
//		float lightDist:		the distance to the light from the surface
//		float lightIntensity:	the intensity of the light
float attenuation(in float lightDist, in float lightIntensity)
{
	// Calulate the distance / intensity for faster calculations
	float distIntensity = lightDist / lightIntensity; 
	return 1. /(1. + distIntensity + (distIntensity * distIntensity) );
}

// lambertian: calculate lambertian reflectance with attenuation
//		vec3 nNorm:				the normalized normal of the surface
//		vec3 nLight:			the normalized vector of the light
//		float lightIntensity:	the intensity of the light
//		float lightDist:		the distance to the light from the surface
float lambertian(in vec3 nNorm, in vec3 nLight, in float lightIntensity, in float lightDist)
{
	// Calculate the diffuse coefficient
	float kD = max(0., dot(nNorm, nLight));
	// Calculate the attenuation
	float atten = attenuation(lightDist, lightIntensity);
	// return the diffuse intensity (diffuse coefficient * attenuation)
	return kD * atten;
}

// phong: calculate phong reflectance
//		vec4 posClip:		the object in clip space (used for the viewer vector)
//		vec4 posSurface:	the position of the surface (view or object)
//		vec3 nLight:		the normalized vector of the light
//		vec3 nNorm:			the normalized normal of the surface
float phong(in vec4 posClip, in vec4 posSurface, in vec3 nLight, in vec3 nNorm)
{
	// Get the normal view vector by subtracting the posSurface from the posClip
	vec3 nViewVec = normalize(vec3(posClip - posSurface));
	// Calculate the reflected light vector by taking the inverse of the light (pointing towards sphere))
	vec3 nRefLightVec = reflect(-nLight, nNorm);
	// Specular coefficient
	float kS = max(0., dot(nRefLightVec, nViewVec));
	// Get the specular intensity by squaring the specular coefficient a lot
	float iS = kS * kS;
	iS *= iS;
	iS *= iS; 
	iS *= iS;
	iS *= iS;  
	return iS;
}

// lighting: calculates the color after lighting the sceen
//		vec4 posClip:			the object in clip space
//		vec4 posSurface:		the position of the surface (view or object)
//		vec3 nNorm:				the normalalized normal of the surface
//		LightingInfo li:		the lighting info
//		vec4 lightColor:		the color of the light
//		float lightIntensity:	the intensity of the light
//		vec4 surfColor:			the color of the surface
//		vec3 lightDir:			the normalized direction of the light
vec4 lighting(in vec4 posClip, in vec4 posSurface, in vec3 nNorm, in LightingInfo li, in vec4 lightColor, in float lightIntensity,
			  in vec4 surfColor, in vec3 lightDir)
{

	float iD = lambertian(nNorm, lightDir, 100., li.lightDist);
	float iS = phong(posClip, posSurface, lightDir, nNorm);
	return (iD * surfColor + iS * vec4(1.)) * lightColor;
}

void main()
{
	vec4 color;

	// Perform the perspective divide on the position in clip space to get the NDC
	vec4 ndc = vPosClip / vPosClip.w;
	// Convert the NDC to a UV
	vec2 uv = ndc.xy * 0.5 + 0.5;
	vec4 normal = vNormal;
	LightingInfo lightingInfo[2];
	
	#ifdef TEXTURE
	// Get the appropriate surface color and normal
	vec4 surfColor = texture(uTex, uv);
	normal = texture(uTexNormalMap, uv);
	color = surfColor;
	#endif
	
	#ifdef SOLIDCOLOR
	vec4 surfColor = vec4(1.0, 0.5, 0.5, 1.0);
	color = surfColor;
	#endif
	
	#ifdef LIGHTING
	color = vec4(0.0);
	for(int i = 1; i >= 0; --i)
	{
		// Initialize the lighting info and then calculate lighting
		initLightingInfo(vPosSurface, vLightPos[i], lightingInfo[i]);
		color += lighting(vPosClip, vPosSurface, vec3(normal), lightingInfo[i], 
						vLightColor[i], vLightIntensity[i], surfColor, vLightDir[i]);
	}
	#endif
	rtFragColor = color;
}