//   Copyright 2020 Colin Deane
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//	   		http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//	 File name: Image
//	 Purpose: Contains a multitude of effects that are coded for use in ShaderToy
//
//	 Contributors:
//	 Daniel Buckstein - Provided a lot of the framework for the gradient effect
//	 Peter Shirley - Provided the formula for calculating if a point is in a circle.
//		Formula taken from his Raytracing in One Weekend book: https://raytracing.github.io/books/RayTracingInOneWeekend.html
//	 Shadertoy - the base for the color changing functionality

#define colorRGB	vec3
#define colorRGBA	vec4

// This effect produces a static gradient with the colors green, yellow, black, and red
// Part of this code was provided by Daniel Buckstein
vec4 gradient(in vec2 fragCoord, in vec2 resolution)
{
    // Have to 'normalize' the coordinates since color is clamped from 0 to 1
    // and coordinates can range from 0 to the resolution size
   	vec2 uv = fragCoord/resolution;
    
    // The red and green component change based on the coordinate, blue is always .1
    // This way the desired gradient can be achieved
    colorRGB color = vec3(uv, 0.1);
    float alpha = 1.0;
    return colorRGBA(color, alpha);
}

// Colors the screen in a blue/red checkboard with a square size that can be edited
vec4 checkerboard(in vec2 fragCoord, in float squareSize)
{
    colorRGBA color;						// This is the color that will be returned
    colorRGBA blue = vec4(0.0,0.0,0.8,1.0); // Create a value for the color blue
    colorRGBA red = vec4(0.8,0.0,0.0,1.0);	// Create a value for the color read
    
    // For this next segment it's easy to visual each case in terms of a 2x2 grid
    // The top left and bottom right of this 2x2 grid is blue
    // The top right and bottom left of this 2x2 grid is red

    // If the x coordinate modulus double the squareSize is less than square size
    if(mod(fragCoord.x, squareSize * 2.0) < squareSize)
    {
        // If the y coordinate modulus double the square size is less than square size
        if(mod(fragCoord.y, squareSize * 2.0) < squareSize)
        {
            // We are in the bottom left of the 2x2 grid and it should be red
        	color = red; 
        }
        else // y coordinate is greater than square size
        {
            // We are in the top left of the 2x2 grid and it should be blue
         	color = blue; 
        }
    }
    else // x coordinate is greater than square size
    {
        // If the y coordinate modulus double the square size is greater than square size
        if(mod(fragCoord.y, squareSize * 2.0) > squareSize) 
        {
            // We are in the top right of the 2x2 grid and it should be red
         	color = red;    
        }
        else // y coordinate is less than square size
        {
            // We are in the bottom right of the 2x2 grid and it should be blue
    		color = blue; 
        }
    }
    
    return color;
    
}

// Have a circle in the center of the screen that changes in size and color
// The background color is the complementary color
// Formula for calculating if a point is inside the circle provided by Peter Shirley
vec4 changingCircle(in vec2 fragCoord, in float time, in vec2 resolution)
{
    // Get the coordinates for the center of the screen (where the circle will be)
    float centerX = resolution.x / 2.0;
    float centerY = resolution.y / 2.0;
    // Get the radius (range goes from 20 to 220)
    float radius = 120.0 + 100.0 * cos(time);
    
    // Have to take out the center coordinate to see if point is in circle
    float xMinusCenter = fragCoord.x - centerX;
    float yMinusCenter = fragCoord.y - centerY;
    // Add a varying green value
    // This also causes an abrupt color change when it jumps from 1.0 to .1
    float gValue = (mod(time, 10.0) + 1.0) / 10.0;
    
    // Calculate the background color
    // Absolute value is used to keep them from 0 to 1
    colorRGB color = vec3(abs(sin(time)), gValue, abs(cos(time)));
    
    // if (x - Cx)^2 + (y - Cy)^2 <= radius^2 then the point is inside the circle
    if(pow(xMinusCenter, 2.0) + pow(yMinusCenter, 2.0) <= pow(radius, 2.0))
       {
           // Inverse the color by subtracting the background color from one
           color = vec3(1.0 - color.r, 1.0 - color.g, 1.0 - color.b);
       }
    
    
	
   
    return vec4(color, 1.0);
}

// Has a space background that changes color and circles that move across the screen
// Formula for calculating if a point is inside the circle provided by Peter Shirley
// If pasting this into Shadertoy please use the "Stars" background from the textures pages in iChannel0
vec4 crazyEffect(in vec2 fragCoord, in vec2 resolution, in float time, in sampler2D backgroundTexture)
{
    
    vec2 uv = fragCoord / resolution;
    // Create a base color based on the texture in the background
    colorRGB baseColor = abs(0.5* cos(time+uv.xyy + vec3(1, 3, 2))); // Changing color based on Shadertoy base code (starts at gray)
    																 // Make sure to take the absolute value to keep it between 0 and 1
    baseColor *= vec3(texture(backgroundTexture, uv));
    
    // Create an orange circle that goes around the entire screen
    float radius = 50.0 + 25.0 * cos(time);
    vec2 circle1;
    // The circle will move from 1/4 screen's x to 3/4 screen's x
    circle1.x = fragCoord.x - (cos(time) * (resolution.x / 4.0) + (resolution.x / 2.0));
    // The circle will move from 1/3 screen's y to 2/3 screen's y
    circle1.y = fragCoord.y - (sin(time) * (resolution.y / 3.0) + (resolution.y / 2.0)); 
    
    // This circle will be orange
    if(pow(circle1.x, 2.0) + pow(circle1.y, 2.0) <= pow(radius, 2.0))
    {
     	baseColor = vec3(1.0, 0.5, 0.0);   
    }
    
    // Create the second circle that goes across the screen horizontally
    radius = 100.0;
    vec2 circle2;
    // The circle will move from 1/4 screen's x to 3/4 screen's x
    circle2.x = fragCoord.x - (cos(iTime) * (resolution.x / 4.0) + (resolution.x / 2.0)); 
    circle2.y = fragCoord.y - (resolution.y / 2.0);
    
    // This circle will inverse the color of whatever is there
    if(pow(circle2.x, 2.0) + pow(circle2.y, 2.0) <= pow(radius, 2.0))
    {
        baseColor = vec3(1.0 - baseColor.r, 1.0 - baseColor.g, 1.0 - baseColor.b);
    }
    
    // Create the third circle that goes across the screen vertically
    radius = 45.0;
    vec2 circle3;
    circle3.x = fragCoord.x - resolution.x / 2.;
    // The circle will move from 1/3 screen's y to 2/3 screen's y
    circle3.y = fragCoord.y - (sin(time) * (resolution.y / 3.0) + (resolution.y / 2.0));
    
    if(pow(circle3.x, 2.0) + pow(circle3.y, 2.0) <= pow(radius, 2.0))
    {
        // Splits the circle in half
        if(mod(circle3.x, 2.0) > circle3.x / 2.0)
        {
        baseColor = 1.0 *abs(sin(time + uv.xyx + vec3(0, 4, 6))); // Changing color based on Shadertoy base code (starts at white)
            													  // Make sure to take the absolute value to keep it between 0 and 1
        }
        else
        {
         baseColor = 1.0 * abs(cos(time + uv.xxy+ vec3(8, 1, 3))); // Changing color based on Shadertoy base code (starts at white)
            													   // Make sure to take the absolute value to keep it between 0 and 1
        }
    }
    
	return vec4(baseColor, 1.0);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    
    
    fragColor = gradient(fragCoord, iResolution.xy);
    
    //fragColor = checkerboard(fragCoord, 32.0);
    
    //fragColor = changingCircle(fragCoord, iTime, iResolution.xy);
    
    //fragColor = crazyEffect(fragCoord, iResolution.xy, iTime, iChannel0);
}