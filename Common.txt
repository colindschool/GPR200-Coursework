// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> COMMON TAB (shared with all other tabs)
// Edited by: Colin Deane
// Edit description: Added structures and methods

//------------------------------------------------------------
// TYPE ALIASES & UTILITY FUNCTIONS

// sScalar: alias for a 1D scalar (non-vector)
#define sScalar float

// sCoord: alias for a 2D coordinate
#define sCoord vec2

// sDCoord: alias for a 2D displacement or measurement
#define sDCoord vec2

// sBasis: alias for a 3D basis vector
#define sBasis vec3

// sPoint: alias for a point/coordinate/location in space
#define sPoint vec4//   Copyright 2020 Colin Deane
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//	   		http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//		File name: Buffer A
//		Purpose: The bulk of my shader. Do raymarching and generate waves based on noise / FBM.
//		Additionally, do the lighting of both the cube and the waves.
//
// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN
//  -> BUFFER A TAB (scene)

// CONSTANTS NEEDED FOR THE WAVES
const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.01;
const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);

//------------------------------------------------------------
// NOISE FUNCTIONS

// noise: Generate value noise from a noise texture (returns a value from 0 to 1)
//		in vec3 v: The vector used for sampling
//		vec3 p: the floored vector of the input vector
//		vec3 f: the fractional vector of the input vector
//
// Most of the implementation of this function comes from Inigo Quilez
// Source: https://www.shadertoy.com/view/4sS3zG
float noise(in vec2 v)
{
	vec2 p = floor(v);
    vec2 f = fract(v);
    // Perform the smoothstep function manually
	f = f*f*(3.-2.*f);
    // Calculate a place to sample from based on the xy
    // Add the smoothstepped fractional vector
	vec2 uv = (p+vec2(16.,64.)) + f;
    // Get the red/green part of the texture to convert to 2D.
	vec2 rg = texture( iChannel0, (uv+.5) * 0.00390625).xy;
    // Return a mix of the redgreen components
	return mix(rg.x, rg.y, 0.5);
} 

// OLD:
// fbm6: Calculate the Fractional Brownian Motion using 6 octaves
// Additionally, move the point the noise is sampling at over time
//
// The numbers of this function come from programmersought.com
// Source: https://www.programmersought.com/article/75884340325/

// Matrix used for calculating displacement
//const mat2 mtx = mat2( 0.8,  0.60, -0.60,  0.80 );
//float fbm6( vec2 point ) {
//  float final = 0.0;
//  // Adjust the point that the noise is sampling over time
//  point += vec2(iTime *.5, 0.);
//  // Get the final color value over time by sampling the noise texture a lot
//  final += 0.500000*noise(point); point = mtx * point * 2.02; // Matrix multiplication of the point at the end here
//  final += 0.250000*noise(point); point = mtx * point * 2.03;
//  final += 0.125000*noise(point); point = mtx * point * 2.01;
//  final += 0.062500*noise(point); point = mtx * point * 2.04;
//  final += 0.031250*noise(point); point = mtx * point * 2.01;
//  final += 0.015625*noise(point);
//  return final * 1.03225806452;
//}

//------------------------------------------------------------
// SEA FUNCTIONS
// ALL OF THE FOLLOWING FUNCTIONS WERE DERIVED FROM Alexander Alekseev (TDM)
//		"Seascape"
//		Source link: https://www.shadertoy.com/view/Ms2SD1

// seaOctave: part of fbm calculations.
//		uv: the uv coordinate that is turned into sound
//		choppy: how choppy the sea is
//	Optimized by: Colin Deane
float seaOctave(in vec2 uv, in float choppy)
{
	uv += noise(uv);
    // Generate a sin curve based on uv
    vec2 swv = sin(uv);
    vec2 wv = 1.0 - (swv * swv);
    return pow(1.0 - (wv.x * wv.y), choppy);
    
    // OLD:
   	// uv += noise(uv);
    // vec2 wv = 1.0-abs(sin(uv));
    // vec2 swv = abs(cos(uv));
    // wv = mix(wv, swv, wv);
    // return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}

// seaHeight: calculate the height of waves when raymarching.
//	Basically, a modified version of a SDF plane
//		vec3 p: the point at which to sample
float seaHeight(in vec3 p, in float time)
{
 	// WAVE DATA
 	float freq = 0.4;	// Frequency of the waves
    float amp = 0.4;	// Amplitude of the waves
    float choppy = 5.0;	// How choppy the waves are
    // Establish some uv coordinates at the point's x & z coordinates.
    // These will be manipulated
    vec2 uv = p.xz;
    uv.x *= 0.75;
    
    float seaTime = time * 0.8;
    float d, h = 0.0;
    // OLD FOR LOOP: for(int i = 0; i < 3; i++)
    // Loop that basically performs FBM on a wave to displace it
    for(int i = 3; i > 0; --i)
    {
     	d = seaOctave((uv+seaTime) * freq, choppy);
        d += seaOctave((uv-seaTime) * freq, choppy);
        h += d * amp;
        // Multiply the uv by an octave matrix (seen above)
        uv *= octave_m;
        // Double the frequency, slash the amplitude into a 5th of what it was.
        // This is for gradual, realistic waves
        freq *= 1.9;
        amp *= 0.22;
        choppy = mix(choppy, 1.0, 0.2);
    }
    // Plane SDF function
    return p.y - h;
}

//------------------------------------------------------------
// RAYMARCHING / DISTANCE FUNCTIONS
//
// The base for these functions come from Inigo Quilez's page on SDF
//		Source link: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm

// cubeSDF: Contains the function for calculating the distance from a cube.
//		I edited it to rotate with the x and to bob up and down with the water
//		p: point to sample at
float cubeSDF(in vec3 p, in float mouseX)
{
    // Get a theta from mouse.x input
    float theta = radians(10.)+ mouseX * .005;
    // Get the cos and sin of that for a rotation matrix
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    
    // Multiply the point by a rotation matrix, resulting in rotP
    vec3 rotP = p * mat3(cosTheta, 0.0, -sinTheta, 0.0, 1.0, 0.0, sinTheta, 0.0, cosTheta);
    // d is where the bobbing up and down is implemented
 	vec3 d = abs(vec3(rotP.x, rotP.y + .25 * cos(iTime) - .5, rotP.z)) - vec3(1.0);
    
    // Get the distance from the inside and outside
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// UNUSED:
// sphereSDF: Has a sphere that changes based on the y of the mouse.
//		p: the point at which to sample at
//		mouseY: the y value of the mouse
//		vp: the viewport, used to calculate the mouse Y variable
float sphereSDF(in vec3 p, in float mouseY, in sViewport vp)
{
     // The sphere is positioned pretty far back
 	 return length(p + vec3(14, 5. * -mouseY * vp.resolutionInv.y, 21.)) - 1.0;
}

// sceneSDF: calculates the SDF for the entire scene.
//		samplePoint: the point at which to sample at
//		hit: a hit record to record if the cube or the waves got hit
float sceneSDF(in vec3 samplePoint, out Hit hit, in float time, in float mouseX)
{
    // OLD:
    //float m = min(sphereSDF(samplePoint), cubeSDF(samplePoint));
    // Calculate the cubeSDF and the planeSDF (seaHeight)
    float c = cubeSDF(samplePoint, mouseX);
    float s = seaHeight(samplePoint, time);
    
    // If the distance to the plane is less than the cube
    if(s <= c)
    {
        // DID NOT hit the cube
       	hit.isCube = false;
        return s;
    }
    else // HIT the cube
    {
     	hit.isCube = true;
        return c;
    } 
}

// raymarch: finds the closest object in the scene by distance
float raymarch(in vec3 eye, in vec3 marchingDirection, in float start,
                                in float end, out Hit hit, in float time, in float mouseX)
{
    float depth = start;
    // OLD FOR LOOP: for(int i = 0; i < MAX_MARCHING_STEPS; i++)
    // Do the marching!
    for (int i = MAX_MARCHING_STEPS; i > 0; --i)
    {
        // Calculate the distance to the closest object!
     	float dist = sceneSDF(eye + depth * marchingDirection, hit, time, mouseX);
        // Is it less than the epsilon?
        if(dist < EPSILON)
        {
            // The ray is close enough to an object
            hit.hDist = depth;
         	return depth;   
        }
        // Otherwise, move along the ray according to the calculated distance
        depth += dist;
        // The ray went too far
        if (depth >= end)
        {
            hit.hDist = end;
         	return end;   
        }
    }
    // The ray took too many steps and did not collide with anything
    hit.hDist = end;
    return end;
}

// estimateNormal: estimate the normal of a surface
// Source of this comes from the Art of Code YouTube channel:
//		Source link: https://youtu.be/PGtv-dBi2wE
vec3 estimateNormal(in vec3 p, out Hit hit, in float time, in float mouseX)
{
    // Normalize a surrounding area of the scene. Calculate the slope from that (and that is the normal)
 	return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), hit, time, mouseX) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), hit, time, mouseX),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), hit, time, mouseX) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), hit, time, mouseX),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), hit, time, mouseX) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), hit, time, mouseX)
    ));
}

//------------------------------------------------------------
// LIGHTING FUNCTIONS

// lBlinnPhong: Blinn-Phong reflectance
//		eye: the position of the camera
//		p: the point at which Blinn-Phong reflectance is being calculated for
//		lv: the normalized light vector
//		n: the normalized normal
float lBlinnPhong(vec3 eye, vec3 p, vec3 lv, vec3 n)
{
    // Calculate the view and halway vector
    vec3 viewVector = normalize(eye - p);
    vec3 halfwayVec = normalize(lv + viewVector);
    
    // Use the specular coefficient to calculate the specular intensity
    float specCo = max(0.0f, dot(n, halfwayVec));
    float specInt = pow(specCo, 200.0);
 	return specInt;   
}

// lLambDifCoef: Calculates the diffuse coefficient for Lambertian shading
//		n: the normalized normal
//		lv: the normalized light vector
float lLambDifCoef(vec3 n, vec3 lv)
{
    float difCoef = max(0., dot(n, lv));
 	return difCoef;	   
}

// lLambAttenuation: Calculates the attenuation of a light
//		light: the PointLight structure that holds the light
//		dist: the distance from the light
float lLambAttenuation(PointLight light, float dist)
{
    // (distance over light intensity)
    float distIntensity = dist / light.lIntensity;
    return 1. / (1. + distIntensity + (distIntensity * distIntensity));
}

// lLambertian: Lambertian shading
//		light: the PointLight structure that holds the light
//		p: the point at which to do shading
//		n: the normalized normal
//		lv: the normalized light vector
//		ld: the distance to the light
float lLambertian(PointLight light, vec3 p, vec3 n, vec3 lv, float ld)
{
 	return lLambDifCoef(n, lv) * lLambAttenuation(light, ld);   
}

// getSkyColor: Gets the color of the sky. Mainly used in the reflection of water
//		e: the vector to calculate the color from. e.y is the only one used
vec3 getSkyColor(vec3 e)
{
 	e.y = (max(e.y,0.0)*0.2+0.4)*0.8;
    float oneMinus = 1.0 - e.y;
    return vec3(oneMinus * oneMinus, oneMinus, 0.6+ oneMinus *0.4) * 1.1;
    //OLD:
    // e.y = (max(e.y,0.0)*0.8+0.2)*0.8;
    // return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;
}

// lighting: The general lighting function that generates light for the cube and waves
//		p: the position to get lighting at
//		eye: the position of the eye of the camera
//		uv: the uv coordinates that range from [0-1]
//		hit: the hit result from the raymarching function
//		video: the video of mr. Van Damme to be sampled from
vec3 lighting(in vec3 p, in vec3 eye, in vec2 uv, inout Hit hit, in sampler2D video, in float time, in float mouseX)
{
    // Construct a point light
 	PointLight light;
    // Initialize the light pretty close to the camera
    initLight(vec3(2.0, 4.0, 3.0), vec3(1.0), 1000., light);
    
    // Estimate the normal
    vec3 n = estimateNormal(p, hit, time, mouseX);
    // Calculate some temporary variables that will be reused
    vec3 distVec = light.center - p;
    float distVecSq = dot(distVec, distVec);
    float lightDist = sqrt(distVecSq);		// the distance from the light to the point
    vec3 lightVec = distVec / lightDist;	// the normalized vector of the light
    
    // Calculate the Lambertian and BlinnPhong reflectance
    float ID = lLambertian(light, p, n, lightVec, lightDist);
    float IS = lBlinnPhong(eye, p, lightVec, n);
    // Set the base color to the ambience
    vec3 ambience = vec3(0.3) * 0.5;
    vec3 color = ambience;
    
    // IF THE RAY HIT THE WAVES
    if(hit.isCube == false)
    {
        //  Create a water color = surface color
        vec3 waterColor = vec3(0.48, 0.54, 0.36);
        // Fresnel shading to get the light facing toward the camera
        float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
        // Cube it
        fresnel *=  fresnel * fresnel * 0.3;
        // Get the reflected sky color
        vec3 reflected = getSkyColor(reflect(eye, n));
        // Get the refracted color based on the attenuation
        vec3 refracted = vec3(0.0,0.1,0.18) + ID * waterColor * .13;

        // Mix the refracted and reflected value based on fresnel value
        color = mix(refracted, reflected, fresnel);
        // Add the BlinnPhong value
        color += IS;
        // Add the water color * the height of the plane
        color += waterColor * (p.y - .5) * .18;
        // RETURN THIS COLOR FOR THE WAVES
        return color;
    }
    
    // ELSE: hit.isCube = true
    // Adjust the uv so Mr. Van Damme can appear appropriately on the cube
    uv *= 3.;
    uv.x += .85;
    // The y changes slightly over time to account for the cube bobbing
    uv.y += .7 + (.1 * cos(time));
    
    // get the color of the surface (aka sample the texture)
    vec3 surfaceColor = vec3(texture(video, uv));   
    color += (ID * surfaceColor + IS * vec3(1.0)) * light.color;
    
    return color;
}

//------------------------------------------------------------
// SHADERTOY MAIN

// mainImage: process the current pixel (exactly one call per pixel)
//    fragColor: output final color for current pixel
//    fragCoord: input location of current pixel in image (in pixels)
void mainImage(out color4 fragColor, in sCoord fragCoord)
{
    // viewing plane (viewport) inputs
    const sBasis eyePosition = vec3(10.0, 5.0, 14.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz, 45.0, iResolution.xy, fragCoord);
 
    // OLD:
    //fragColor = vec4(fbm6(ray.direction.xy * 2.));
    
    // Create a conversion from the camera to the world
    mat4 viewToWorld = viewMatrix(eyePosition, vec3(0.0), vec3(0.0, 1.0, 0.0));
    
    // Calculate the view from the world direction (TO ROTATE THE CAMERA)
    vec3 worldDir = (viewToWorld * vec4(ray.direction, 0.0)).xyz;
    
    // Create a hit structure and then raymarch
    Hit hit;
    raymarch(eyePosition, worldDir, MIN_DIST, MAX_DIST, hit, iTime, iMouse.x);
    
    // If there is no hit
    if(hit.hDist > MAX_DIST - EPSILON)
    {
        // Create a blend of blue for the sky.
        vec3 normDir = normalize(worldDir);
        float blendAmount = 0.5 * (normDir.y + 1.0);
     	fragColor = mix(vec4(1.0), vec4(0.2, 0.7, 1.0, 1.0), blendAmount);
        return;
    }
    
    // The closest point on the surface to the eyepoint along the view ray;
    vec3 p = eyePosition + hit.hDist * worldDir;
    // Color the scene by calling the lighting function
    vec3 color = lighting(p, eyePosition, vp.uv, hit, iChannel1, iTime, iMouse.x);
    fragColor = vec4(color, 1.0);
}

// sVector: alias for a vector/displacement/change in space
#define sVector vec4


// color3: alias for a 3D vector representing RGB color
// 	(this is non-spatial so neither a point nor vector)
#define color3 vec3

// color4: alias for RGBA color, which is non-spatial
// 	(this is non-spatial so neither a point nor vector)
#define color4 vec4


// asPoint: promote a 3D vector into a 4D vector 
//	representing a point in space (w=1)
//    v: input 3D vector to be converted
sPoint asPoint(in sBasis v)
{
    return sPoint(v, 1.0);
}

// asVector: promote a 3D vector into a 4D vector 
//	representing a vector through space (w=0)
//    v: input 3D vector to be converted
sVector asVector(in sBasis v)
{
    return sVector(v, 0.0);
}


// lengthSq: calculate the squared length of a vector type
//    x: input whose squared length to calculate
sScalar lengthSq(sScalar x)
{
    return (x * x);
    //return dot(x, x); // for consistency with others
}
sScalar lengthSq(sDCoord x)
{
    return dot(x, x);
}
sScalar lengthSq(sBasis x)
{
    return dot(x, x);
}
sScalar lengthSq(sVector x)
{
    return dot(x, x);
}

// UTILITY FUNCTIONS
// getColorNormalized: Gets the normalized color of a texel at a certain point
//		point: 		the point at which to sample from
//		sampText:	the texture to sample from
//		normalizer:	the amount that is required to normalize the color
color4 getColorNormalized(in sCoord point, in sampler2D sampText, in float normalizer)
{
 	vec4 color = texture(sampText, point) * normalizer;   
    return color;
}

// calcLuma: Gets the luma of a color that is input
//		color:	input color to get the brightness of
//	Source for the luma values comes from David Wolff's GLSL 4.0 Cookbook
//		Link: https://people.inf.elte.hu/plisaai/pdf/David%20Wolff%20-%20OpenGL%204.0%20Shading%20Language%20Cookbook%20(2).pdf
//			Page number 166 (179 in PDF)
float calcLuma(in color4 color)
{
 	return 0.21 * color.r + 0.72 * color.g + 0.07 * color.b;   
}

//------------------------------------------------------------
// VIEWPORT INFO

// sViewport: info about viewport
//    viewportPoint: location on the viewing plane 
//							x = horizontal position
//							y = vertical position
//							z = plane depth (negative focal length)
//	  pixelCoord:    position of pixel in image
//							x = [0, width)	-> [left, right)
//							y = [0, height)	-> [bottom, top)
//	  resolution:    resolution of viewport
//							x = image width in pixels
//							y = image height in pixels
//    resolutionInv: resolution reciprocal
//							x = reciprocal of image width
//							y = reciprocal of image height
//	  size:       	 in-scene dimensions of viewport
//							x = viewport width in scene units
//							y = viewport height in scene units
//	  ndc: 			 normalized device coordinate
//							x = [-1, +1) -> [left, right)
//							y = [-1, +1) -> [bottom, top)
// 	  uv: 			 screen-space (UV) coordinate
//							x = [0, 1) -> [left, right)
//							y = [0, 1) -> [bottom, top)
//	  aspectRatio:   aspect ratio of viewport
//	  focalLength:   distance to viewing plane
struct sViewport
{
    sPoint viewportPoint;
	sCoord pixelCoord;
	sDCoord resolution;
	sDCoord resolutionInv;
	sDCoord size;
	sCoord ndc;
	sCoord uv;
	sScalar aspectRatio;
	sScalar focalLength;
};

// initViewport: calculate the viewing plane (viewport) coordinate
//    vp: 		      output viewport info structure
//    viewportHeight: input height of viewing plane
//    focalLength:    input distance between viewer and viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void initViewport(out sViewport vp,
                  in sScalar viewportHeight, in sScalar focalLength,
                  in sCoord fragCoord, in sDCoord resolution)
{
    vp.pixelCoord = fragCoord;
    vp.resolution = resolution;
    vp.resolutionInv = 1.0 / vp.resolution;
    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;
    vp.focalLength = focalLength;
    vp.uv = vp.pixelCoord * vp.resolutionInv;
    vp.ndc = vp.uv * 2.0 - 1.0;
    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;
    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * 0.5, -vp.focalLength));
}


//------------------------------------------------------------
// RAY INFO

// sRay: ray data structure
//	  origin: origin point in scene
//    direction: direction vector in scene
struct sRay
{
    sPoint origin;
    sBasis direction;
};

// initRayPersp: initialize perspective ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
void initRayPersp(out sRay ray,
             	  in sBasis eyePosition, in sBasis viewport, in float fieldOfView, 
                  in vec2 size, in vec2 fragCoord )
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    ray.origin = asPoint(eyePosition);

    vec2 xy = fragCoord - size * 0.5;
    float z = size.y / tan(radians(fieldOfView) * 0.5);
    ray.direction = normalize(vec3(xy, -z));
}

// initRayOrtho: initialize orthographic ray
//    ray: 		   output ray
//    eyePosition: position of viewer in scene
//    viewport:    input viewing plane offset
//void initRayOrtho(out sRay ray,
//             	  in sBasis eyePosition, in sBasis viewport)
//{
    // offset eye position to point on plane at the same depth
//    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);
//}

// viewMatrix creates a matrix to convert from the camera to the world
mat4 viewMatrix(vec3 eye, vec3 center, vec3 up)
{
 	vec3 f = normalize(center - eye);
    vec3 s = normalize(cross(f, up));
    vec3 u = cross(s, f);
    return mat4(
    	vec4(s, 0.0),
        vec4(u, 0.0),
        vec4(-f, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
   	);
}

// Structure for a PointLight
struct PointLight
{
	vec3 center; // Location of light source
    vec3 color;	 // The color of the light
    float lIntensity; // The intensity of the light
    
};

// Initialize a PointLight structure
void initLight(in vec3 center, in vec3 color, in float intensity,
               out PointLight light)
{
    light.center = center;			// Center of the light
    light.color = color;			// Color of the light
    light.lIntensity = intensity;	// Intensity of the light
      
}

// Structure for a Hit
//		hDist: the distance from the hit
//		isCube: did the ray hit a cube?
struct Hit
{
 	float hDist;
  	bool isCube;  
};
