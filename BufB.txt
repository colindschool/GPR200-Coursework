const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.0001;

float cubeSDF(vec3 p)
{
 	vec3 d = abs(p) - vec3(1.0);
    
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}
float seaOctave(vec2 uv, float choppy)
{
	uv = texture(iChannel0, uv).rr;
    vec2 wv = 1.0-abs(sin(uv));
    vec2 swv = abs(cos(uv));
    wv = mix(wv, swv, wv);
    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
}
const mat2 mtx = mat2( 0.8,  0.60, -0.60,  0.80 );
float planeSDF(vec3 p, vec2 uv)
{
    float frequency = .16;
    float amplitude = .6;
    float choppy = 4.0;
    vec2 pd = p.xz;
    
    float d, h =0.0;
    for(int i = 0; i < 3; i++)
    {
        d = seaOctave(uv * frequency, choppy);  
        h += d * amplitude;
    	uv *= mtx;
        frequency *= 1.9;
        amplitude *= 0.22;
        choppy = mix(choppy, 1.0, 0.2);
    }
    vec4 c = texture(iChannel0, uv);
 	//return dot(p, normalize(vec3(0.0, 1.0, 0.0))) + 25. + c.r;
    return p.y - h;
}

float sphereSDF(vec3 p)
{
 	 return length(p + vec3(14, 5. * -iMouse.y / iResolution.y, 21.)) - 1.0;
}

float sceneSDF(vec3 samplePoint, vec2 uv)
{
    float m = min(sphereSDF(samplePoint), cubeSDF(samplePoint));
 	return min(m, planeSDF(samplePoint, uv));   
}

float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, vec2 uv)
{
    float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++)
    {
     	float dist = sceneSDF(eye + depth * marchingDirection, uv);
        if(dist < EPSILON)
        {
         	return depth;   
        }
        depth += dist;
        if (depth >= end)
        {
         	return end;   
        }
    }
    return end;
}

vec3 estimateNormal(vec3 p, vec2 uv)
{
 	return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), uv) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), uv),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), uv) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), uv),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), uv) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), uv)
    ));
}

// Structure for a PointLight
struct PointLight
{
	vec3 center; // Location of light source
    vec3 color;	 // The color of the light
    float lIntensity; // The intensity of the light
    
};

// Initialize a PointLight structure
void initLight(in vec3 center, in vec3 color, in float intensity,
               out PointLight light)
{
    light.center = center;			// Center of the light
    light.color = color;			// Color of the light
    light.lIntensity = intensity;	// Intensity of the light
      
}

float lBlinnPhong(vec3 eye, vec3 p, vec3 lv, vec3 n)
{
    vec3 viewVector = normalize(eye - p);
    vec3 halfwayVec = normalize(lv + viewVector);
    
    float specCo = max(0.0f, dot(n, halfwayVec));
    float specInt = pow(specCo, 200.0);
 	return specInt;   
}

float lLambDifCoef(vec3 n, vec3 lv)
{
    float difCoef = max(0., dot(n, lv));
 	return difCoef;	   
}

float lLambAttenuation(PointLight light, float dist)
{
    float distIntensity = dist / light.lIntensity;
    return 1. / (1. + distIntensity + (distIntensity * distIntensity));
}

float lLambertian(PointLight light, vec3 p, vec3 n, vec3 lv, float ld)
{
 	return lLambDifCoef(n, lv) * lLambAttenuation(light, ld);   
}

vec3 lighting(vec3 p, vec3 eye, vec2 uv)
{
 	PointLight light;
    initLight(vec3(1.0, 2.0, 2.0), vec3(1.0), 100., light);
    vec3 n = estimateNormal(p, uv);
    
    vec3 tempVec = light.center - p;
    float tempFlt = dot(tempVec, tempVec);
    float lightDist = sqrt(tempFlt);
    vec3 lightVec = tempVec / lightDist;
    
    float ID = lLambertian(light, p, n, lightVec, lightDist);
    float IS = lBlinnPhong(eye, p, lightVec, n);
    
    vec3 ambience = vec3(0.2) * 0.5;
    vec3 color = ambience + (ID * vec3(0.5, 0.0, 0.5) + IS * vec3(1.0)) * light.color;
    
    return color;
}

mat4 viewMatrix(vec3 eye, vec3 center, vec3 up)
{
 	vec3 f = normalize(center - eye);
    vec3 s = normalize(cross(f, up));
    vec3 u = cross(s, f);
    return mat4(
    	vec4(s, 0.0),
        vec4(u, 0.0),
        vec4(-f, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
   	);
}

vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)
{
 	vec2 xy = fragCoord - size * 0.5;
    float z = size.y / tan(radians(fieldOfView) * 0.5);
    return normalize(vec3(xy, -z));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord / iResolution.xy;
    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);
    vec3 eye = vec3(8.0, 1.0, 12.0);
    
    mat4 viewToWorld = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));
    
    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;
    
    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, uv);
    
    if(dist > MAX_DIST - EPSILON)
    {
        vec3 normDir = normalize(worldDir);
        float blendAmount = 0.5 * (normDir.y + 1.0);
        float mouseY = iMouse.y / iResolution.y;
     	fragColor = mix(vec4(1.0), vec4(0.2, 0.7, 1.0, 1.0), blendAmount);
        return;
    }
    
    // The closest point on the surface to the eyepoint along the view ray;
    vec3 p = eye + dist * worldDir;
    
    vec3 color = lighting(p, eye, uv);
    fragColor = vec4(color, 1.0);
}
