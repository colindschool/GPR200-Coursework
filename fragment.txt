#version 300 es

//   Copyright 2020 Colin Deane
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//	   		http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//	 File name: fragment.glsl
//	 Purpose: Either output the light if lighting is done per-vertex
//		or calculate the light if the lighting is done per-fragment
//
//	Contributors:
//		Daniel Buckstein provided a lot of the knowledge and starter framework behind this code
//		NASA for the image of the moon (used as a texture map)
//			Source: https://nasa3d.arc.nasa.gov/detail/as08-17-2670

#define PF
// PV - Per-vertex
// PF - Per-fragment

#ifdef GL_ES
precision highp float;
#endif // GL_ES

layout (location = 0) out vec4 rtFragColor;
// out vec4 rtFragColor

uniform sampler2D uTextureMap;

// VARYING
in vec4 vTexcoord;
#ifdef PV
in vec4 vColor;
#endif

#ifdef PF
in vec4 vPosClip;
in vec4 vPosSurface;
in vec3 vNLight[3];
in float vLightDist[3];
in vec4 vLightColor[3];
in float vLightInt[3];
in vec4 vNormal;
#endif

// attenuation: calculate attenuation for the light
//		float lightDist:		the distance to the light from the surface
//		float lightIntensity:	the intensity of the light
float attenuation(in float lightDist, in float lightIntensity)
{
	// Calulate the distance / intensity for faster calculations
	float distIntensity = lightDist / lightIntensity; 
	return 1. /(1. + distIntensity + (distIntensity * distIntensity) );
}

// lambertian: calculate lambertian reflectance with attenuation
//		vec3 nNorm:				the normalized normal of the surface
//		vec3 nLight:			the normalized vector of the light
//		float lightIntensity:	the intensity of the light
//		float lightDist:		the distance to the light from the surface
float lambertian(in vec3 nNorm, in vec3 nLight, in float lightIntensity, in float lightDist)
{
	// Calculate the diffuse coefficient
	float kD = max(0., dot(nNorm, nLight));
	// Calculate the attenuation
	float atten = attenuation(lightDist, lightIntensity);
	// return the diffuse intensity (diffuse coefficient * attenuation)
	return kD * atten;
}

// phong: calculate phong reflectance
//		vec4 posClip:		the object in clip space (used for the viewer vector)
//		vec4 posSurface:	the position of the surface (view or object)
//		vec3 nLight:		the normalized vector of the light
//		vec3 nNorm:			the normalized normal of the surface
float phong(in vec4 posClip, in vec4 posSurface, in vec3 nLight, in vec3 nNorm)
{
	// Get the normal view vector by subtracting the posSurface from the posClip
	vec3 nViewVec = normalize(vec3(posClip - posSurface));
	// Calculate the reflected light vector by taking the inverse of the light (pointing towards sphere))
	vec3 nRefLightVec = reflect(-nLight, nNorm);
	// Specular coefficient
	float kS = max(0., dot(nRefLightVec, nViewVec));
	// Get the specular intensity by squaring the specular coefficient a lot
	float iS = kS * kS;
	iS *= iS;
	iS *= iS; 
	iS *= iS;
	iS *= iS;  
	return iS;
}

// lighting: calculates the color after lighting the sceen
//		vec4 posClip:			the object in clip space
//		vec4 posSurface:		the position of the surface (view or object)
//		vec3 nNorm:				the normalalized normal of the surface
//		vec3 nLight:			the normalized light vector
//		float lightDist:		the distance to the light from the surface
//		vec4 lightColor:		the color of the light
//		float lightIntensity:	the intensity of the light
//		sampler2D texMap:		the texture to sample from
vec4 lighting(in vec4 posClip, in vec4 posSurface, in vec3 nNorm, in vec3 nLight,
			  in float lightDist, in vec4 lightColor, in float lightIntensity,
			  in sampler2D texMap)
{

	float iD = lambertian(nNorm, nLight, 100., lightDist);
	float iS = phong(posClip, posSurface, nLight, nNorm);
	return (iD * texture(texMap, vTexcoord.xy) + iS * vec4(1.)) * lightColor;
}

// Either output the lighting
// Or calculate the lighting
void main()
{

 	// PER-FRAGMENT inputs used to calculate final color
 	// Do all the lighting calculations in here
  	#ifdef PF
  	vec4 N = normalize(vNormal); 
    
  	rtFragColor = lighting(vPosClip, vPosSurface, vec3(N), vNLight[0], vLightDist[0],
  							 vLightColor[0], vLightInt[0], uTextureMap);
  	rtFragColor +=  lighting(vPosClip, vPosSurface, vec3(N), vNLight[1], vLightDist[1],
  							 vLightColor[1], vLightInt[1], uTextureMap);
  	rtFragColor +=  lighting(vPosClip, vPosSurface, vec3(N), vNLight[2], vLightDist[2],
  							 vLightColor[2], vLightInt[2], uTextureMap);  
  	#endif
  	
  	// PER-VERTEX
  	// Just output the color received from the vertex shader
  	#ifdef PV
  	rtFragColor = vColor;  
  	#endif
} 